# -*- coding: utf-8 -*-
"""trabalhoICD (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mDETMbE0A6cbsN9ElVk1xI-1alGsVB9r
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

data = pd.read_csv('fifa.csv')
data.head()

"""## Processamento de dados"""

#retirando colunas irrelavantes
data.drop(['Unnamed: 0','ID','Photo', 'Flag', 'Club Logo', 'Loaned From'], axis=1, inplace=True)
cols = [i for i in range(22,49)]
data.drop(data.columns[cols], axis = 1, inplace=True)

#arrumando a altura e o peso
pd.options.display.max_columns = 90
data['Weight'] =  data['Weight'].str[:3].astype(float) /  2.205
data['Height(cm)'] = data['Height'].str.split("'") 
data['Height'] = (12 * data['Height(cm)'].str[0].astype(float) + data['Height(cm)'].str[1].astype(float)) * 2.54
data.drop(['Height(cm)'], axis=1, inplace=True)
data.rename({'Height': 'Height (cm)', 'Weight': 'Weight (kg)'},axis=1, inplace=True)

#arrumando o valor, salário e cláusula de quebra
s = pd.Series(['Value','Wage','Release Clause'])
for i in s:
  data['aux1'] = data[i].str.extract('(€\d+)')
  data['aux1'] = data['aux1'].str.extract('(\d+)')
  data['aux1'] = data['aux1'].astype(float)
  data['aux2'] = data[i].str.extract('(\.\d+)')
  data['aux2'].fillna(0, inplace=True)
  data['aux2'] = data['aux2'].astype(float)
  data[i] = data['aux1'] + data['aux2']
  data.drop(['aux1', 'aux2'],axis=1,inplace=True)

#Arrumando os tipos corporais
data.loc[data['Body Type'] == 'Akinfenwa', 'Body Type'] = 'Stocky'
data.loc[data['Body Type'] == 'Neymar', 'Body Type'] = 'Lean'
data.loc[data['Body Type'] == 'Messi', 'Body Type'] = 'Lean'
data.loc[data['Body Type'] == 'C. Ronaldo', 'Body Type'] = 'Stocky'
data.loc[data['Body Type'] == 'Shaqiri', 'Body Type'] = 'Stocky'
data.loc[data['Body Type'] == 'Courtois', 'Body Type'] = 'Normal'
data.loc[data['Body Type'] == 'PLAYER_BODY_TYPE_25', 'Body Type'] = 'Normal'

#Agora só há três tipos
set(data['Body Type'])

#tamanho normal
data.shape

#tamanho depois de remover os nulos (diferença de ~1500)
data = data.dropna()
data.shape

"""## Análise explatória de dados (Thales)"""

#A "cara" do dataset:
display(data.head())

attribute = data.groupby(['Nationality'], as_index = False).count()
#attribute = attribute[['Nationality', 'Name']]
attribute = pd.DataFrame(attribute[['Nationality', 'Name']]).sort_values(by = 'Name', ascending = False)
attribute = attribute[:10]

#attribute['Name'].plot.bar(x = 'Nationality', xlabel = 'País', title = 'Salário médio por nacionalidade', ylabel = 'Valor (milhares de euros)', legend=False, figsize = (7,7))
attribute.plot.bar(x = 'Nationality', title = 'Nº jogadores por país', figsize = (7,7), legend = False)

attribute = data.groupby(['Nationality'], as_index = False).mean()
attribute = pd.DataFrame(attribute[['Nationality', 'Wage']]).sort_values(by = 'Wage', ascending = False)
attribute = attribute[:10]

attribute.plot.bar(x = 'Nationality', xlabel = 'País', title = 'Salário médio por país', ylabel = 'Valor (milhares de euros)', legend=False, figsize = (7,7))

attribute = data.groupby(['Nationality'], as_index = False).median()
attribute = pd.DataFrame(attribute[['Nationality', 'Wage']]).sort_values(by = 'Wage', ascending = False)
attribute = attribute[:10]

attribute.plot.bar(x = 'Nationality', xlabel = 'País', title = 'Salário mediano por país', ylabel = 'Valor (milhares de euros)', legend=False, figsize = (7,7))

#Médias dos atributos por tipo corporal:
attribute = data.groupby(['Body Type'], as_index = False).mean()

#A maioria das categorias são iguais para todos os grupos, mas essas apresentam algumas diferenças:
attribute = pd.DataFrame(attribute[['Body Type', 'Acceleration', 'Agility', 'Dribbling', 'Strength','Aggression']]).sort_values(by = ['Acceleration', 'Agility', 'Dribbling', 'Strength','Aggression'])

#Percebe-se que os atletas magros são, em média, um pouco mais rápidos, agéis e driblam melhor.
#Os mesormorfos são mais pesados, fortes e agressivos

attribute.plot.bar(x ='Body Type', xlabel = 'Tipo Corporal', ylabel ='Valor (adimensional)', title='Média dos atributos por tipo corporal', figsize = (8,10))
plt.legend(loc = 4, prop = {'size': 10})

attribute = data.groupby(['Body Type'], as_index = False).mean()
attribute = pd.DataFrame(attribute[['Body Type', 'Release Clause']]).sort_values(by = 'Release Clause')
attribute.plot.bar(x = 'Body Type', xlabel = 'Tipo Corporal', title = 'Valor médio da clásula de quebra', ylabel = 'Valor (milhões de euros)', legend=False, figsize = (7,7))

#Vamos considerar as medianas dos mesmos atributos
attribute_median = data.groupby(['Body Type'], as_index = False).median()
attribute_median = pd.DataFrame(attribute_median[['Body Type', 'Release Clause']]).sort_values(by = 'Release Clause')
attribute_median.plot.bar(x = 'Body Type', xlabel = 'Tipo Corporal', title = 'Valor mediano da clásula de quebra', ylabel = 'Valor (milhões de euros)', legend=False, figsize = (7,7))

attribute_median = data.groupby(['Body Type'], as_index = False).mean()
attribute_median = pd.DataFrame(attribute_median[['Body Type', 'Value']]).sort_values(by = 'Value')
attribute_median.plot.bar(x = 'Body Type', xlabel = 'Tipo Corporal', title = 'Valor médio do jogador', ylabel = 'Valor (milhões de euros)', legend=False, figsize = (7,7))

attribute_median = data.groupby(['Body Type'], as_index = False).median()
attribute_median = pd.DataFrame(attribute_median[['Body Type', 'Value']]).sort_values(by = 'Value')
attribute_median.plot.bar(x = 'Body Type', xlabel = 'Tipo Corporal', title = 'Valor mediano do jogador', ylabel = 'Valor (milhões de euros)', legend=False, figsize = (7,7))

attribute_position = pd.DataFrame(data.groupby(['Position']).mean()['Wage'])
attribute_position = attribute_position.sort_values(by = 'Wage')
attribute_position.plot.bar(title = "Salário médio por posição")

attribute_position = pd.DataFrame(data.groupby(['Position']).median()['Wage'])
attribute_position = attribute_position.sort_values(by = 'Wage')
attribute_position.plot.bar(title = "Salário mediano por posição")

"""O ponto principal é que a visualização dos dados pode mudar muito dependendo da estatística sendo analisada. Isto é, diferenças que existem na média podem não existir quando consideramos a mediana (e vice-versa)."""

#Será que a chance pode explicar essa diferença?
#No mundo aleatório, a distribuição de salários seria independente
#da posição do jogador
#Façamos um teste de permutação

# df = data[['Wage','Position']].copy()

# filter = ((df['Position'] == 'RF'))
# print('Média das outras posições : ', round(df[~filter]['Wage'].mean(), 2))
# print('Média das posições RF/LF: ', round(df[filter]['Wage'].mean(), 2))
# print('A diferença: ', round(df[filter]['Wage'].mean(), 2) - round(df[~filter]['Wage'].mean(), 2))

# n = 5000
# values = np.zeros(n)

# for i in range(n):
#   #np.random.seed(i)
#   #np.random.shuffle(filter.values)
#   sample = df.sample(len(df), replace = True)
#   values[i] = sample[filter]['Wage'].median()

# plt.hist(values, bins = 50)

# print(dif)
# total = len(dif)
# sum_greater = 0

# for i in dif:
#   if i >= 40:
#     sum_greater += 1

# sum_greater

#Porém, vamos analisar os dados para a mediana:
# attribute_position = pd.DataFrame(data.groupby(['Position']).median()['Wage'])
# attribute_position = attribute_position.sort_values(by = 'Wage')
# attribute_position.plot.bar()

"""Os resultados para a mediana são bem menos impressionantes. A diferença aqui é de apenas 7K, enquanto que para a média, era de 42k, seis vezes mais. Como interpretar isso? Muito provavelmente, existem jogadores em RF/LF que estão puxando a média para cima. Na prática, essas posições não são necessariamente as melhores do ponto de vista financeiro.

## Hipótese I (Leandro)
"""

data.loc[data['Position'] == "GK"].sort_values("Height (cm)", ascending=False)
data.sort_values("Height (cm)", ascending=False)

data.head(10)

"""**Hipótese**

Se um jogador brasileiro ganha mais que um jogador argentino e se isso é isso é provado aleatoriamente ou por um outro motivo alem de "u"

*uSerBrasileiro != uSerArgentino*

"""

#data = pd.read_csv('fifa.csv', index_col='ID')
brasilArgentina = data.loc[(data['Nationality'] == 'Brazil') | (data['Nationality'] == 'Argentina')].sort_values('Wage', ascending = False)
brasilArgentina['log_wage'] = np.log(brasilArgentina['Wage'])

meanPlot = brasilArgentina[['Nationality','Wage']].groupby("Nationality").agg([np.mean])
meanPlot.plot(kind = "bar", y = "Wage", legend = False,
            title = "Média Salarial dos jogadores")

g = sns.catplot(x="Nationality", y="log_wage", kind="violin", inner=None, data=brasilArgentina)
sns.swarmplot(x="Nationality", y="log_wage", color="k", size=0.5, data=brasilArgentina, ax=g.ax)

"""Pelo violin plot é possível perceber que existem menos jogadores brasileiro que recebem "pouco" comparado aos jogadores argentinos, onde no centro do "violiono" brasileiro é possivel reparar que ele é mais "aberto", representando uma quantidade maior de jogadores com salario "médio"."""

def bootstrap_mean(df1, df2, column, n=1000):
    size1 = len(df1)
    size2 = len(df2)
    values1 = np.zeros(n)
    values2 = np.zeros(n)
    values_diff = np.zeros(n)
    for i in range(n):
        sample1 = df1[column].sample(size1, replace=True, random_state=i)
        sample2 = df2[column].sample(size2, replace=True, random_state=i*3)
        values1[i] = sample1.mean()
        values2[i] = sample2.mean()
        values_diff[i] = sample1.mean() - sample2.mean()
    return values1, values2, values_diff

brasil = brasilArgentina[brasilArgentina['Nationality']=='Brazil']
argentina = brasilArgentina[brasilArgentina['Nationality']=='Argentina']
col = 'log_wage'
v_brasil, v_argentina, v_diff = bootstrap_mean(brasil, argentina, col)

bp_data = [v_brasil, v_argentina]
plt.rcParams['figure.figsize']  = (8, 6)
plt.boxplot(bp_data, whis=[5, 95], positions=[1,2], showfliers=False, showmeans=True)
plt.xticks([1,2], ['Brasil', 'Argentina'], fontsize=10)
plt.ylabel('', fontsize=13)
plt.xlabel('Nacionalidade', fontsize=12)
plt.title('Salário (log) Médio dos Jogadores por Nacionalidade', fontsize=14)
plt.show()

"""**Teste A/B**

Realizando um teste *A/B* sobre os salários (em *log*) dos jogadores, percebemos que com 5% de chance os jogadores brasileiros se encontram com o mesmo salário que os argentinos, provando que com os dados usados no FIFA nesse ano, os brasileiros ganham mais que os argentinos

# Regressão (Rodrigo)
"""

cols = ['Age', 'Wage']
series = data[cols].groupby('Age', as_index=False).mean()
series

plt.rcParams['figure.figsize']  = (18, 10)
plt.rcParams['axes.labelsize']  = 20
plt.rcParams['axes.titlesize']  = 20
plt.rcParams['legend.fontsize'] = 20
plt.rcParams['xtick.labelsize'] = 20
plt.rcParams['ytick.labelsize'] = 20
plt.rcParams['lines.linewidth'] = 4
plt.ion()

plt.style.use('seaborn-colorblind')
plt.rcParams['figure.figsize']  = (12, 8)

ols = ['Age', 'Wage']

series = data[cols].groupby('Age', as_index=False).mean()
series

def beta(series, mean_x, mean_y):
    num = 0
    den = 0
    for i in range(len(series)):
        num += (series.iloc[i][0] - mean_x) * (series.iloc[i][1] - mean_y)
        den += (series.iloc[i][0] - mean_x) ** 2
    return num/den

mean_x = np.mean(series['Age'])
mean_y = np.mean(series['Wage'])
beta = beta(series, mean_x, mean_y)
beta

alpha = mean_y - beta*mean_x
alpha

fig,ax = plt.subplots()
x = np.linspace(10.,50.)
ax.plot(x,beta*x+alpha)
x = np.array(series.iloc[:len(series)-1,0].values).reshape((-1,1)) 
y = np.array(series.iloc[:len(series)-1,1].values).reshape((-1,1))
plt.scatter(x,y,color="black")
plt.show()

from sklearn.linear_model import LinearRegression

model = LinearRegression()
x = np.array(series.iloc[:len(series)-1,0].values).reshape((-1,1)) 
y = np.array(series.iloc[:len(series)-1,1].values).reshape((-1,1))

model.fit(x,y)
new_y = model.predict(x)
plt.scatter(x,y,color="black")
plt.plot(x,new_y,color="blue", linewidth=1)

from sklearn.preprocessing import PolynomialFeatures
poly_reg = PolynomialFeatures(degree=2)
X_poly = poly_reg.fit_transform(x)

lin_reg2 = LinearRegression()
lin_reg2.fit(X_poly,y)
from sklearn.preprocessing import PolynomialFeatures
poly_reg = PolynomialFeatures(degree=4)
X_poly = poly_reg.fit_transform(x)
lin_reg2 = LinearRegression()
lin_reg2.fit(X_poly,y)
  
X_grid = np.arange(min(x),max(x),0.1)
X_grid = X_grid.reshape(len(X_grid),1) 
plt.scatter(x,y, color='red') 
  
plt.plot(X_grid, lin_reg2.predict(poly_reg.fit_transform(X_grid)),color='blue') 
  
plt.title("Salário por Idade")
plt.xlabel('Idade')
plt.ylabel('Salário')
plt.show()

"""# Outras Regressões (Hélio)"""

from sklearn.datasets import load_diabetes
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

data.reset_index(drop=True, inplace=True)
s = data[['Height (cm)']].round(2)
s['Count p/ Altura'] = s.groupby('Height (cm)')['Height (cm)'].transform('count')
s = s.sort_values(['Height (cm)'])
j = s.drop_duplicates(subset = ["Height (cm)","Count p/ Altura"])
j.reset_index(inplace=True, drop=True)
j.plot.bar(x='Height (cm)',y='Count p/ Altura',figsize=(10,6))

def error(alpha, beta, x, y):
    return y - alpha - beta*x

def sum_of_squared_errors(alpha, beta, x, y):
    result = 0
    index = 0
    while index < len(y):
      result += (error(alpha,beta,x[index],y[index]))**2
      index += 1
    result = result

    return result

def total_sum_of_squares(y):
    result = 0
    mean = y.mean()

    for element in y:
      result += (element - mean)**2
    result 

    return result

def r_squared(alpha, beta, x, y):
    SQT = total_sum_of_squares(y)
    SQR = sum_of_squared_errors(alpha,beta,x,y)

    return (SQT - SQR)/SQT

def linear_regression(x,y):
  alpha = 0
  beta = 0
  mean_x = x.mean()
  mean_y = y.mean()

  index = 0
  covariancia = 0
  variancia = 0
  while index < len(y):
    covariancia += (x[index] - mean_x)*(y[index] - mean_y)
    index += 1
  covariancia = covariancia/len(y)
  index = 0
  while index < len(x):
    variancia += (x[index] - mean_x)**2
    index += 1
  variancia = variancia/len(x)
  beta = covariancia/variancia
  alpha = mean_y - beta*mean_x

  return (alpha, beta)

def correlacao(x_name,y_name):
  x = data[x_name]
  y = data[y_name]
  x = x[:10000]
  y = y[:10000]
  print("jj")
  (alpha,beta) = linear_regression(x,y)
  print("Alpha , Beta:")
  print((alpha,beta))
  print("Coeficiente de Determinação:")
  print(r_squared(alpha,beta,x,y))
  plt.plot(data[x_name], data[y_name],'o')
  plt.plot(data[x_name], alpha + beta*data[x_name], color='r')

correlacao('Height (cm)','Acceleration')

correlacao('Height (cm)','Dribbling')

correlacao('Height (cm)','Marking')

correlacao('Height (cm)','Balance')

correlacao('Height (cm)','Interceptions')

correlacao('Height (cm)','Strength')

correlacao('Height (cm)','Strength')

df = data[['Position','Height (cm)']]
df = df.dropna()

def set_values(row, value):
    return value[row]

map_dictionary ={"ST": 9, "CF": 9,
                 "RF" : 8, "LF": 8,
                 "LS" : 7, "RS" : 7,
                 "CAM": 6, "RAM" : 6, "LAM" : 6, "LW" : 6,"RW" : 6,
                 "RCM" : 5, "LCM" : 5, "RM" : 5,"LM" : 5,"CM" : 5,
                 "LDM" : 4, "CDM" : 4, "RDM" : 4,
                 "RWB" : 3, "LWB" : 3,
                 "RCB": 2, "CB": 2, "LCB": 2,
                 "LB": 1, "RB": 1,
                 "GK": 0} 

df['Position_Num'] = df['Position'].apply(set_values, args =(map_dictionary, )) 



df = df.reset_index()
y = df['Height (cm)']
x = df['Position_Num']

(alpha,beta) = linear_regression(x,y)
print("Alpha , Beta:")
print((alpha,beta))
plt.plot(df['Position_Num'], df['Height (cm)'],'o')
plt.plot(df['Position_Num'], alpha + beta*df['Position_Num'], color='magenta')
plt.rcParams["figure.figsize"] = [7.50, 3.50]
plt.rcParams["figure.autolayout"] = True
print("Coeficiente de Determinação:")
print(r_squared(alpha,beta,x,y))

"""## Template de Regressão"""

#modelo de regressão

from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt

#cria-se um modelo
model = LinearRegression()

#é só mudar os valores de x e y com as colunas que vocês quiserem
x = np.array(data['Height (cm)'].values).reshape((-1,1))
y = np.array(data['Agility'].values).reshape((-1,1))

model.fit(x,y)
new_y = model.predict(x)

#resultado
#parece que a altura e a agilidade estão inversamente correlacionados
plt.scatter(x, y, color="black", s=1, edgecolor='k', alpha=0.75)
plt.plot(x, new_y,color="blue", linewidth=1)

"""# A fazer:

* Mais regressões e hipóteses
* Arrumar os gráficos
* Intervalos de confiança e p-valor
* Entrega por streamlit
* Algo mais?



"""